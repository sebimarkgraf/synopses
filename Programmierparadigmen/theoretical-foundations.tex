
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "propa"
%%% End:

\newcommand\alphaeq{\overset{\alpha}{=}}
\newcommand\etaeq{\overset{\eta}{=}}

\section{Theoretische Grundlagen}

\subsection{Kalküle}
\begin{itemize}
  \item Minimalistische Programmiersprachen zur Beschreibung von Berechnungen
  \item Zum Führen von Beweisen
\end{itemize}
In dieser Vorlesung \(\lambda\)-Kalkül für sequentielle Sprachen

\subsection{untypisiertes \(\lambda\)-Kalkül}
\begin{tabular}{l l l}
  \textbf{Bezeichnung} & \textbf{Notation} & \textbf{Beispiele}\\
  Variablen & \(x\) & \code{x y}\\
  Abstraktion & \(\lambda x.\ t\) & \code{\(\lambda\)y. 0}\\
  Funktionsanwendung & \(t_1\ t_2\) & \code{f 42}
\end{tabular}\\\\
Die Funktionsanwendung ist \textit{linksassoziativ}: \code{\(\lambda\)x. f x y = \(\lambda\)x ((f x)y)}

% TODO: Add shadowing?

\subsection{\(\alpha\)-Äquivalenz}
Gedanke: 2 Terme sind äquivalent, wenn die Variablen in Lambdas des einen Terms in den anderen umbennant werden können.\\
Definition: \(t_1\) und \(t_2\) heißen \(\alpha\)-äquivalent (\(t_1 \alphaeq t_2\)), wenn \(t_1\) in \(t_2\) durch konsitente
Umbennung der \(\lambda\)-gebundenen Variablen überführt werden kann.

\subsection{\(\eta\)-Äquivalenz}
Gedanke: 2 Terme sind äquivalent, wenn Sie immer das gleiche Ergebnis haben.\\
Definition: \(\lambda x.\ f\ x\) und \(f\) heißen \(\eta\)-äquivalent (\(\lambda x.\ f\ x \etaeq f\)), falls \(x\)
nicht freie Variable von \(f\).

\subsection{Ausführung von \(\lambda\)-Termen}
Redex: Von Englisch \textit{Reducable Expression} ein vereinfachbarer \(\lambda\)-Term\\
\(\beta\)-Reduktion: Ausführen der Funktionsanwendung auf einem Redex \[(\lambda x.\ t_1)\ t_2 \Rightarrow t_1 [x \rightarrow t_2]\]\\
Substitution: \(t_1 [x \rightarrow t_2]\) ersetze freie Vorkommen von \(x\) in \(t_1\) durch \(t_2\)\\
Normalform: Termn kann nicht weiter reduziert werden.

\subsection{Auswertungsstrategien}
Oft mehrere Terme in Ausdruck \(\Rightarrow\) Welchen wertet man zuerst aus?\\
Volle \(\beta\)-Reduktion: Alle Terme bis zum Ende ausgewertet
\begin{itemize}
  \item Normalreihenfolge: Immer der linkeste äußerste Redex --- Normalform ist eindeutig
  \item Call-By-Name: Reduziere linkesten äußeren Redex, falls nicht von \(\lambda\) umgeben
  \item Call-By-Value: Reduziere linkesten äußeren Redex, falls nicht von \(\lambda\) umgeben und Argument ein Wert
\end{itemize}
Die letzten beiden Varianten werten nicht immer zur Normalform aus!

\subsection{Church-Zahlen}
Natürliche Zahlen lassen sich als Lambda Terme ausdrücken.
Idee: Verstehe natürliche Zahlen, als Anzahl der Funktionsanwendungen \code{s}. Dann:
\begin{lstlisting}
  $c_0$ = $\lambda$s. $\lambda$z. z
  $c_1$ = $\lambda$s. $\lambda$z. s z
  ...
  $c_n$ = $\lambda$s. $\lambda$z. $s^n$ z

\end{lstlisting}
Um die nächste Church Zahl zu erhalten wird die Nachfolgerfunktion \coce{succ} definiert.
Außerdem lassen sich auch Mathematische Operationen definieren.
\begin{lstlisting}
  succ = $\lambda$n. $\lambda$s. $\lambda$z. s (n s z)
  plus = $\lambda$m. $\lambda$n. $\lambda$s. $\lambda$z. m s (n s z)
  times = $\lambda$m. $\lambda$n. $\lambda$s. n (m s)
  exp = $\lambda$m. $\lambda$n. n m
\end{lstlisting}
Auch Booleans lassen sich so kodieren. Dabei sind diese eine einfache Fallunterscheidung
\begin{lstlisting}
  $c_{true}$ = $\lambda$t. $\lambda$f. t
  $c_{false}$ = $\lambda$t. $\lambda$f. f
\end{lstlisting}
Test auf 0
\begin{lstlisting}
  isZero = $\lambda$n. n ($\lambda$x. $c_{false}$) $c_{true}$
\end{lstlisting}

\subsection{Divergenz}