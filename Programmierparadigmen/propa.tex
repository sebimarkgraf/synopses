\documentclass[10pt,a4paper]{article}
\author{Sebastian Markgraf}
\title{Programmierparadigmen}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage[activate={true,nocompatibility},final,tracking=true,kerning=true,spacing=true,factor=1100,stretch=10,shrink=10]{microtype}
% activate={true,nocompatibility} - activate protrusion and expansion
% final - enable microtype; use "draft" to disable
% tracking=true, kerning=true, spacing=true - activate these techniques
% factor=1100 - add 10% to the protrusion amount (default is 1000)
% stretch=10, shrink=10 - reduce stretchability/shrinkability (default is 20/20)
\microtypecontext{spacing=nonfrench}

\def\realnumbers{{\rm I\!R}}
\def\naturalnumbers{{\rm I\!N}}
\def\complexnumbers{{\mathbb{C}}}
\def\code#1{\texttt{#1}}

\lstset{language=Haskell}

\begin{document}
	\pagenumbering{Roman}
	{\let\newpage\relax\maketitle}
	\tableofcontents
	\newpage
	\pagenumbering{arabic}
	\setcounter{page}{1}

        \section{Funktionale Programmierung in Haskell}

        \subsection{Funktion}
        Entspricht in Sprachen wie Haskell der mathematischen Sicht:
        \begin{itemize}
          \item Bildet Element aus Definitions- in Wertebereich ab
          \item Auswertung keine Effekte auf Daten des Programms
          \item Wert von \(f(x)\) alleine von \(x\) abhängig
        \end{itemize}
        Es gibt keine Variablen in Haskell, Zustand über Parameter \& Rückgabewert.  

        \subsection{Funktionsdefinition}
        \code{f x = sin x / x}\\
        Defininiere Funktionen mit Leerzeichen um Parameter zu trennen.\\

        
        \subsection{Rekursive Definitionen}
        Definition mit if-else-then:
        \begin{lstlisting}
          binom n k =
            if (k == 0) || (k == n)
            then 1
            else binom (n-1) (k-1) + binom (n-1) k
        \end{lstlisting}
        Oder mit Type Guard Notation:
        \begin{lstlisting}
          binom n k
            | (k == 0) || (k == n) = 1
            | otherwise = binom (n-1) (k-1) + binom (n-1) k
        \end{lstlisting}
        Vergleichbar mit Mathematischer Notation

        \subsection{Ausführung}
        Ausführung mit \code{ghci}\\
        Programm \code{simple.hs}:
        \begin{lstlisting}
          square x = x * x
          cube x = x * square x
        \end{lstlisting}
        Laden und Ausführen:
        \begin{lstlisting}[language=bash]
          ghci
          :l simple.hs
          cube (1+2)
        \end{lstlisting}

        \subsection{Auswertung}
        Schrittweise ausgewertet
        \begin{itemize}
          \item \(e_1 \Rightarrow e_2\) für einen Schritt
          \item \(e_1 \Rightarrow^+ e_n \) falls \(e_1 \Rightarrow e_2 \Rightarrow ... \Rightarrow e_n\)
        \end{itemize}
        
        \subsection{Akkumulatoren}
        Auswertung von rekursiven Funktionen \(\Rightarrow\) Zwischenausdrücke wachsen mit Eingabegröße.\\
        Deshalb: Verwende Akkumulatoren\\
        Idee: Speichere partielle Ergebnisse
        \begin{lstlisting}
          fakAcc n acc = if (n==0) then acc else fakAcc (n-1) (n*acc)
          fak n = fakAcc n 1
        \end{lstlisting}

        \subsection{Endrekursion}
        Funktion heiß endrekursiv, falls in jedem Zweig der rekursive Aufruf nicht in einen anderen Aufruf eingebettet ist.

        \subsection{Listen}
        Liste ist entweder
        \begin{itemize}
          \item leere Liste \code{[]}, oder
          \item List \code{(x:xs)}, Restlist \code{xs} und Listenkopf \code{x}
        \end{itemize}
\end{document}